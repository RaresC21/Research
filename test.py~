import numpy as np
import matplotlib.pyplot as plt
from mpl_toolkits.mplot3d import Axes3D
from matplotlib.patches import FancyArrowPatch
from mpl_toolkits.mplot3d import proj3d


point  = np.array([0.84635944, 0.16090509, 0.75181841])
normal = np.array([-0.887044, 0.35163571, 0.29917374])

point2 = np.array([10, 50, 50])

# a plane is a*x+b*y+c*z+d=0
# [a,b,c] is the normal. Thus, we have to calculate
# d and we're set
d = -point.dot(normal)

# create x,y
nx, ny = (3, 2)
x = np.linspace(0.5, 1, nx)
y = np.linspace(0.5, 1, ny)
xx, yy = np.meshgrid(x, y)

# calculate corresponding z
z = (-normal[0] * xx - normal[1] * yy - d) * 1. /normal[2]

# plot the surface
plt3d = plt.figure().gca(projection='3d')
plt3d.plot_surface(xx, yy, z, alpha=0.2)

# draw sphere

fig = plt.figure()
ax = fig.gca(projection='3d')
ax.hold(True)
ax.set_aspect("equal")

r = np.sqrt(3) / 10
u, v = np.mgrid[0:2*np.pi:20j, 0:np.pi:10j]
x = 1 + np.cos(u)*np.sin(v) * r
y = 0.1 + np.sin(u)*np.sin(v) * r
z = 0.7 + np.cos(v) * r
plt3d.plot_wireframe(x, y, z, color="r")

# draw line

p1 = np.array([0.87729431, 0.14223333, 0.71471556])
direction = np.array([-0.59731151, 0.36052697, 0.71640719])
p2 = p1 + direction * 0.03

print(p1, p2)

plt3d.plot([p1[0], p2[0]], [p1[1], p2[1]], [p1[2], p2[2]])

plt.show()
