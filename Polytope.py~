from scipy.optimize import linprog
import numpy as np
from Plane import Plane, Options
from Utils import marginal

import time

class Polytope:
    def __init__(self, A, b, pt, options = Options()):
        self.A = A
        self.b = b
        self.dimension = A.shape[1]
        self.num_planes = A.shape[0]
        self.options = options

        self.planes = []
        for i in range(self.num_planes):
            p = Plane(A[i], b[i], self.options, plane_id = i)
            self.planes.append(p)

        self.point = pt

        self.cur_lines__ = [[self.point, self.point]]
        self.centroid_distance = []
        self.centroid_change = []
        self.facet_hit = []
        self.angles = []
        #self.marginal_direction = np.zeros(self.dimension)
        #self.marginal_direction[0] = 1
        self.marginal_direction = np.random.random(self.dimension)
        self.last_marginal = []
        self.it = 10
        self.all_marginals = []
        self.all_marginal_diffs = []

    def marginal_width(self):
        # how far can I go in the direction and still be in the polytope?
        d = 0.01
        while True:
            A = np.vstack([self.A, self.marginal_direction])
            b = np.append(self.b, -np.dot(self.marginal_direction,
                                         self.point + d * self.marginal_direction))
            res = linprog(self.marginal_direction, A_ub=A, b_ub=b, bounds=(None,None))
            if res.status == 2:
                break
            else:
                d = d * 2

        d1 = d
        d = 0.01
        while True:
            A = np.vstack([self.A, self.marginal_direction])
            b = np.append(self.b, np.dot(self.marginal_direction,
                                         self.point - d * self.marginal_direction))
            res = linprog(self.marginal_direction, A_ub=A, b_ub=b, bounds=(None,None))
            if res.status == 2:
                break
            else:
                d = d * 2

        return d1/2, d/2

    def pt_in_polytope(self, pt):
        for plane in self.planes:
            if not plane.pt_in_half_plane(pt):
                return False
        return True

    def get_plane_hit(self, pt, direction, last_plane_hit):
        dist = 0
        indx = -1

        intersection = np.zeros(self.dimension)
        d = direction

        for i, plane in np.ndenumerate(self.planes):
            if plane.pt_on_hyperplane(pt):
                continue

            if self.options.reflection == "facet":
                hit, v = plane.reflect(pt, direction)
            elif self.options.reflection == "sphere":
                hit, v = plane.reflect_sphere(pt, direction, plane_id = last_plane_hit)

            # if (np.linalg.norm(hit) > 1e5) :continue
            cur_dist = np.linalg.norm(pt - hit)
            # print("inside polytope", self.pt_in_polytope(hit), hit)
            if self.pt_in_polytope(hit) and (indx == -1 or dist > cur_dist):
                indx = i[0]
                dist = cur_dist
                intersection = hit
                d = v
        return intersection, d, indx

    def reflection_lines(self, iterations, continue_ = False):
        if not continue_:
            direction = np.random.random(self.dimension)
            pt = self.point
        else:
            direction = self.reflection_direction
            pt = self.reflection_point

        average = np.zeros(self.dimension)
        length = 0

        indx = -1
        line = []
        last_plane_hit = -1
        for i in range(iterations):
            nxt_pt, nxt_direction, last_plane_hit = self.get_plane_hit(pt, direction, last_plane_hit)
            self.facet_hit.append(last_plane_hit)
            self.angles.append(np.pi/2 - np.arccos(np.dot(direction, self.planes[last_plane_hit].perp_vec) / np.linalg.norm(direction)))
            if continue_:
                line = (pt, nxt_pt)
            else:
                line.append((pt, nxt_pt))

            l = np.linalg.norm(nxt_pt - pt)

            prev_average = average
            average = (average * length + l * nxt_pt) / (l + length)
            length += l

            pt = nxt_pt

            dd = np.linalg.norm(average)
            self.centroid_distance.append(dd)
            self.centroid_change.append(np.linalg.norm(average - prev_average))
            #print(i, dd)
            direction = nxt_direction
        self.reflection_direction = direction
        self.reflection_point = pt
        return line

    def compute_average(self, lines) :
        centroid = np.zeros(self.dimension)
        line_lengths = 0
        for l in lines:
            cur_len = np.linalg.norm(l[0] - l[1])
            cur_pt = (l[0] + l[1]) / 2.0
            centroid = centroid + cur_pt * cur_len
            line_lengths += cur_len
        return centroid / line_lengths

    def approximate_centroid(self, iterations = 1e100, get_all = False):
        centroid = self.point
        average_centroid = centroid
        averages = [centroid]
        cents = [centroid]

        lines = []
        pt = self.point
        print("START", pt)
        #direction = np.ones(self.dimension) + np.random.randn(self.dimension)/5
        direction = np.random.random(self.dimension)
        # direction = np.array([-0.70499, -0.76752, 0.76134, -0.20046, -1.57117])
        print("initial direction", direction)

        it = 1
        average_lines = pt
        total_len = 0
        last_plane_hit = -1

        cnt = 1
        while cnt < 1000:
            cnt+=1

            next_pt, next_d, last_plane_hit = self.get_plane_hit(pt, direction, last_plane_hit)
            if np.linalg.norm(next_pt) < 1e-5:
                # lines = lines[-10:]
                # lines.append((pt, pt + next_d))
                break
            lines.append([pt, next_pt])

            if it == 1:
                centroid = (lines[0][0] + lines[0][1]) / 2.0
                l = np.linalg.norm(lines[0][0] - lines[0][1])
                average_lines = centroid * l
                total_len = l
            else:
                c = (lines[-1][0] + lines[-1][1]) / 2.0
                l = np.linalg.norm(lines[-1][0] - lines[-1][1])
                centroid = (centroid * total_len + l * c) / (total_len + l)
                total_len += l

            next_centroid = (average_centroid * it + centroid) / (it + 1)
            averages.append(next_centroid)
            cents.append(centroid)

            ddd = np.sqrt(np.dot(centroid, centroid))
            self.centroid_distance.append(ddd)
            # print("pt, cnt", cnt, next_pt, next_d)
            # for plane in self.planes:
            #     ball = plane.nearest_gridpoint(next_pt)
            #     print("dist", np.linalg.norm(ball - next_pt), plane.options.radius)
            # print("direction", next_d)
            print("centroid", cnt, ddd)

            # diff = np.linalg.norm(next_centroid - average_centroid)
            # if not self.different_marginal(lines, cnt) and cnt > 100:
                # print("iterations:", cnt)
                # break

            '''
            if cnt == iterations or (iterations > 1e10 and diff < 0.0001):
                print("iterations:", it)
                break
            '''

            average_centroid = next_centroid
            direction = next_d
            pt = next_pt
            it += 1

        if get_all:
            return averages, cents
        else:
            n = 10
            m = np.zeros(len(averages[0]))
            for a in cents[-n:]:
                m = m + a
            m = m / len(cents[-n:])
            return m, lines #self.cur_lines__

    def is_redundant(self, vec, b):
        A = np.copy(self.A)
        bb = np.copy(self.b)

        A = np.vstack([A, vec])
        bb = np.append(bb, b + 1)

        c = -1.0 * vec

        result = linprog(c, A_ub=A, b_ub=bb, bounds=(None,None))
        if result.success:
            if -result.fun <= b:
                return True
            else:
                return False

    def remove_redundant(self):
        i = 0
        while i < self.num_planes:
            tempA = np.delete(self.A, (i), axis = 0)
            tempB = np.delete(self.b, (i))

            poly = Polytope(tempA, tempB, self.point)
            poly.options = self.options

            if poly.is_redundant(self.A[i], self.b[i]):
                self = poly
            i += 1
        return self

    def different_marginal(self, lines, it, eps = 1e-1):
        if it % 50 != 0: return True
        # self.randomized_distribution(it, self.cur_lines__[-1][1])
        # m = self.cur_lines__
        # m = self.marginal_dist(self.cur_lines__)
        m = self.marginal_dist(lines)
        if len(self.all_marginals) == 0:
            self.all_marginals.append(m)
            return True

        # np.set_printoptions(threshold=np.nan)
        # print(np.array2string(m, separator=', '))

        #print("distribution:", m)

        l = len(self.all_marginals)
        print(self.all_marginals[l//2])
        print(m)
        print()
        print()
        diff = 0
        for i in range(len(m)):
            a = m[i]
            b = self.all_marginals[l//2][i]
            diff = max(diff, abs(a - b))

        print("cnt", it)
        print("marginal change", diff)
        self.all_marginal_diffs.append(diff)
        self.all_marginals.append(m)
        if (diff < eps) : return False
        return True

    def marginal_dist(self, lines):
        num_steps = 10

        marginal_set = []
        for p in range(1,num_steps+1):
            amnt = p / num_steps

            l = 0
            r = 1e2
            start = - self.marginal_direction * 1e1
            while (abs(l - r) > 1e-4):
                mid = (l + r) / 2
                pos = start + self.marginal_direction * mid
                cut = Plane(self.marginal_direction, -np.dot(self.marginal_direction, pos))
                m = marginal(lines, cut)

                #print(m)
                if m < amnt:
                    r = mid
                else:
                    l = mid
            #print(m, amnt, l)
            finish = (l * self.marginal_direction + start)
            dist = np.linalg.norm(finish)
            if np.linalg.norm(start) < np.linalg.norm(start - finish):
                dist *= -1
            marginal_set.append(dist)

        # step = abs(self.marginal_ends[0] + self.marginal_ends[1]) / num_steps
        #
        # pos = self.point - self.marginal_direction * self.marginal_ends[1]
        # for i in range(num_steps):
        #     cut = Plane(self.marginal_direction, -np.dot(self.marginal_direction, pos))
        #     m = marginal(lines, cut)
        #     marginal_set.append(m)
        #
        #     pos += self.marginal_direction * step
        return np.array(marginal_set)


    def randomized_distribution(self, iterations, start_pos = [None, None]):
        print(iterations)
        dimension = self.dimension

        standard_directions = []
        for i in range(dimension):
            cur = np.zeros(dimension)
            cur[i] = 1
            standard_directions.append(cur)
            other = np.zeros(dimension)
            other[i] = -1
            standard_directions.append(other)

        if start_pos[0] != None:
            p = self.point
        else:
            p = start_pos

        lines = []
        for i in range(iterations):
            dir_indx = np.random.randint(len(standard_directions))
            direction = standard_directions[dir_indx]

            hit, _ = self.get_plane_hit(p, direction)

            # choose random point from p to hit
            dist = np.linalg.norm(hit - p)
            length = np.random.uniform(0, dist)

            next_pt = p + direction * length
            lines.append([p, next_pt])
            p = next_pt

        for l in lines:
            self.cur_lines__.append(l)
        # print(self.cur_lines__)
