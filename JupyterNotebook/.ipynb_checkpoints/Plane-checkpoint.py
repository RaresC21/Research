{
  "cells": [
    {
      "metadata": {
        "trusted": true
      },
      "cell_type": "code",
      "source": "import numpy as np\n\nclass Options:\n    def __init__(self, reflection = \"facet\", delta = 0.1, radius = 0.1 * np.sqrt(3), depth = 0):\n        self.reflection = reflection\n        self.delta = delta\n        self.radius = radius\n        self.depth = depth\n\nclass Plane:\n    class Ball:\n        def __init__(self, center, radius):\n            self.center = center\n            self.radius = radius\n\n        def pt_inside(self, pt):\n            dist = np.linalg.norm(pt - self.center)\n\n            if dist < self.radius + 1e-8:\n                return True\n            return False\n\n        def does_intersect(self, o, l) :\n            c = self.center\n            r = self.radius\n\n            l = l / np.linalg.norm(l)\n\n            a = - (np.dot(l, o - c))\n            b = (np.dot(l, (o - c)) ** 2) - (np.linalg.norm(o - c) ** 2) + r*r\n            return b >= -1e-8\n\n        '''\n        circle centered at c, of radius r\n        line: x = o + d * l (origin o, direction l)\n        '''\n        def line_intersection(self, o, l):\n            c = self.center\n            r = self.radius\n\n            l = l / np.linalg.norm(l)\n\n            a = - (np.dot(l, o - c))\n            b = (np.dot(l, (o - c)) ** 2) - (np.linalg.norm(o - c) ** 2) + r*r\n            b = np.sqrt(b)\n\n            d1 = a + b\n            d2 = a - b\n\n            p1 = o + d1 * l\n            p2 = o + d2 * l\n\n            if np.linalg.norm(p1 - o) < np.linalg.norm(p2 - o):\n                return p1\n            return p2\n\n        def reflection(self, pt, direction):\n            hit_on_sphere = self.line_intersection(pt, direction)\n\n            perp = hit_on_sphere - self.center\n            b = np.dot(perp, hit_on_sphere)\n            plane = Plane(perp, b)\n\n            p, d = plane.reflect(pt, direction)\n            # print(pt, direction, hit_on_sphere, p, d, plane.perp_vec)\n            return p, d\n\n    def __init__(self, coef, b, options = Options(), plane_id = -1):\n        norm = np.linalg.norm(coef)\n        self.perp_vec = coef / norm\n        self.b = b / norm\n        self.dimension = coef.shape[0]\n        self.options = options\n        self.plane_id = plane_id\n        self.get_basis()\n\n        pt_on_plane = [0] * self.dimension\n        for i, c in np.ndenumerate(coef):\n            indx = i[0]\n            if abs(c) > 1e-8:\n                pt_on_plane[indx] = b / c\n                break\n        self.pt_on_plane = pt_on_plane\n\n    def get_basis(self):\n        basis = []\n        indx = -1\n        for i, c in np.ndenumerate(self.perp_vec):\n            if abs(c) > 1e-8:\n                indx = i[0]\n                break\n\n        for i, c in np.ndenumerate(self.perp_vec):\n            if i[0] == indx: continue\n            cur = [0] * self.dimension\n            cur[indx] = -c\n            cur[i[0]] = self.perp_vec[indx]\n            cur = np.array(cur)\n            cur = cur / np.linalg.norm(cur)\n            basis.append(cur)\n        self.basis = np.array(basis)\n\n    def pt_in_half_plane(self, pt):\n        return np.dot(pt, self.perp_vec) < self.b + 1e-4\n\n    def pt_on_hyperplane(self, pt):\n        diff = abs(np.dot(pt, self.perp_vec) - self.b)\n        return diff < 1e-8\n\n    def line_intersection(self, point, direction) :\n        num = self.b - np.dot(point, self.perp_vec)\n        denom = np.dot(direction, self.perp_vec)\n        t = num / denom\n        if t < -1e-8: t = 1e9\n        return point + direction * t\n\n    def projection(self, point):\n        return self.line_intersection(point, 1 * self.perp_vec);\n\n    def reflect(self, point, direction):\n        # return self.reflect_function(point, direction)\n\n        # move everything to origin\n        intersection = self.line_intersection(point, direction)\n        pp = point - self.pt_on_plane\n\n        dd = direction\n\n        # mirror the point across the hyperplane\n        proj = self.perp_vec * np.dot(pp, self.perp_vec) \\\n               / np.dot(self.perp_vec, self.perp_vec)\n\n        mirror = pp - 2 * proj + self.pt_on_plane\n        direction = intersection - mirror\n\n        #BB = np.vstack([[self.perp_vec], self.basis])\n        #BB = np.transpose(BB)\n\n        #BBinv = np.linalg.inv(BB)\n        #neg = np.identity(self.dimension)\n        #neg[0,0] *= -1\n\n        #ref = np.matmul(np.matmul(BB, neg), BBinv)\n        #dd = np.matmul(ref, dd)\n        #dd /= np.linalg.norm(dd)\n\n        direction = direction / np.linalg.norm(direction)\n\n        #direction = dd\n\n        return (intersection, direction)\n\n\n    def get_pt_in_basis(self, point) :\n        projection = self.projection(point) - self.pt_on_plane;\n\n        temp = np.vstack([self.basis, [self.perp_vec]])\n        pt_plane_basis = np.linalg.solve(np.transpose(temp), projection)\n\n        pt = np.rint(pt_plane_basis / self.options.delta)\n        return pt * self.options.delta\n\n    def reflect_function(self, point, direction):\n        intersection = self.line_intersection(point, direction)\n        if (np.linalg.norm(intersection) > 1e5):\n            return (intersection, np.zeros(self.dimension))\n\n        on_grid = self.get_pt_in_basis(intersection)\n        pt = self.get_pt_in_basis(self.nearest_gridpoint(intersection))\n        refl_direction = np.zeros(self.dimension)\n        for i in range(self.dimension - 1):\n            p = on_grid[i]\n            x1 = pt[i]\n            x2 = pt[i] + self.options.delta\n            if p - x1 < x2 - p:\n                d = p - x1\n                if d < self.options.delta / 4:\n                    refl_direction += self.basis[i] * d\n                else:\n                    refl_direction += self.basis[i] * ((self.options.delta / 2) - d)\n            else :\n                d = x2 - p\n                if d < self.options.delta / 4:\n                    refl_direction += self.basis[i] * (-d)\n                else:\n                    refl_direction += self.basis[i] * (((self.options.delta / 2) - d) * (-1))\n        refl_direction -= self.perp_vec * self.options.delta;\n        refl_direction /= np.linalg.norm(refl_direction)\n        return (intersection, refl_direction)\n\n    def offset(self):\n        h = np.sqrt(self.options.radius**2 -(self.options.delta/2)**2)\n        return h - self.options.depth\n\n    def translate_plane(self, h) :\n        new_pt = self.pt_on_plane + self.perp_vec * h\n        return Plane(self.perp_vec, np.dot(self.perp_vec, new_pt), self.options)\n\n    def nearest_gridpoint(self, q):\n        projection = self.projection(q) - self.pt_on_plane;\n\n        temp = np.vstack([self.basis, [self.perp_vec]])\n        pt_plane_basis = np.linalg.solve(np.transpose(temp), projection)\n\n        pt = np.rint(pt_plane_basis / self.options.delta)\n        center_plane_basis = pt * self.options.delta\n        center_plane_basis[-1] = 0\n        return np.matmul(np.transpose(temp), center_plane_basis) + self.pt_on_plane\n\n    def next_nearest_ball(self, ball_plane, current_ball, point, direction):\n        l = 0\n        r = 100\n        ans = 0\n        while (abs(r - l) > 1e-6):\n            mid = (l + r) / 2\n#             pt = self.get_pt_in_basis(ball_plane.nearest_gridpoint(point + direction * mid))\n#             cntr = self.get_pt_in_basis(current_ball.center)\n            # print(point + direction * mid, ball_plane.nearest_gridpoint(point + direction * mid), pt, cntr)\n#             if np.linalg.norm(pt - cntr) > self.options.delta / 2:\n            if np.linalg.norm(ball_plane.nearest_gridpoint(point + direction * mid) - current_ball.center) > self.options.delta / 2:\n                r = mid\n                ans = mid\n            else:\n                l = mid\n        return point + direction * ans\n\n    def reflect_sphere(self, point, direction, plane_id = -1):\n        ball_plane = self.translate_plane(self.options.depth)\n\n        onBall = False\n        if plane_id == self.plane_id:\n            print(\"ON BALL\")\n            onBall = True\n        else: \n            print(\"NOT ON BALL\")\n            \n        d = np.linalg.norm(point - self.projection(point))\n\n        if d < self.options.radius + 1e-9:\n            q = point\n        else:\n            off = self.options.radius #self.offset()\n            boundary = self.translate_plane(-off)\n\n            q = boundary.line_intersection(point, direction)\n            if np.linalg.norm(q) > 1e5: \n                print(\"WRONG DIR\")\n                return (np.array([1e8] * self.dimension), 1e8)\n\n#         for k in range(100):\n        while True:\n            dist_to_plane = np.linalg.norm(q - ball_plane.projection(q))\n\n            if dist_to_plane > self.options.delta + self.options.radius: break\n            if onBall:\n                ball = self.Ball(ball_plane.nearest_gridpoint(q), self.options.radius)\n                q = self.next_nearest_ball(ball_plane, ball, q, direction)\n                onBall = False\n            ball = self.Ball(ball_plane.nearest_gridpoint(q), self.options.radius)\n#             print(dist_to_plane, self.options.delta + self.options.radius, ball.center)\n#             print(\"q\", q, ball.center)\n#             print(\"point, direction, next_pt\", onBall, point, self.projection(q), direction, point - direction, ball.center)\n#             print(\"q, bcenter\", q, ball.center, np.linalg.norm(q - ball.center), ball.radius)\n            if ball.does_intersect(point, direction):\n#                 print(\"IN\", np.linalg.norm(ball.center - q), self.options.radius)\n#                 print(\"point, direction, next_pt\", onBall, point, self.projection(q), direction, point - direction, ball.center)\n                intersection, new_direction = ball.reflection(point - direction , direction)\n                dif = (intersection[0] - point[0]) / direction[0]\n                if np.linalg.norm(point - intersection) > 1e5: break\n                if dif > -1e-9: # checks if the intersection is in the opposite direction\n                    other = ball_plane.nearest_gridpoint(intersection)\n                    if np.linalg.norm(other - ball.center) < 1e-5:\n                        # this checked if the point we found is not inside of any other circle. \n#                         print(intersection, q, other, ball.center)\n#                         return (np.zeros(2), 0)\n                        return intersection, new_direction\n#                     else: \n#                         print(\"PROBLEM\")\n#                         print(intersection, q, other, ball.center)\n# #                         exit(0)\n                else: break\n            q = self.next_nearest_ball(ball_plane, ball, q, direction)\n\n        return (np.array([1e8] * self.dimension), 1e8)",
      "execution_count": 3,
      "outputs": []
    },
    {
      "metadata": {
        "trusted": true
      },
      "cell_type": "code",
      "source": "",
      "execution_count": null,
      "outputs": []
    }
  ],
  "metadata": {
    "kernelspec": {
      "name": "python36",
      "display_name": "Python 3.6",
      "language": "python"
    },
    "language_info": {
      "mimetype": "text/x-python",
      "nbconvert_exporter": "python",
      "name": "python",
      "pygments_lexer": "ipython3",
      "version": "3.6.6",
      "file_extension": ".py",
      "codemirror_mode": {
        "version": 3,
        "name": "ipython"
      }
    }
  },
  "nbformat": 4,
  "nbformat_minor": 1
}